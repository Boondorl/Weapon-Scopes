//version "2.4"

class ScopeHandler : EventHandler
{
	private ui double oldFOV;
	private ui Vector2 oldPos;
	
	ui Vector2 pos;
	ui Scope sc;
	ui TextureID lens;
	
	override void WorldLoaded(WorldEvent e)
	{
		// Reset scope drawing if reentering a level
		if (e.isReopen)
		{
			ThinkerIterator it = ThinkerIterator.Create("Scope", Thinker.STAT_DEFAULT);
			Scope mo;
			while (mo = Scope(it.Next()))
			{
				if (mo)
					mo.bDrawScope = false;
			}
			
			return;
		}
		
		// Spawn a scope actor for each player when entering a new level
		for (uint i = 0; i < MAXPLAYERS; ++i)
		{
			if (!playerInGame[i] || !players[i].mo)
				continue;
			
			let cam = Actor.Spawn("Scope");
			if (cam)
				cam.master = players[i].mo;
		}
	}
	
	override void UITick()
	{
		// Check valid player scope
		if (!sc)
			sc = FindScope(consoleplayer);
		
		// Check valid camera texture
		if (!lens.IsValid())
			lens = TexMan.CheckForTexture("SCAMTEX1", TexMan.Type_Any);
		
		// Update scope if weapon camera FOV changed
		double fov = oldFOV;
		let weap = players[consoleplayer].ReadyWeapon;
		if (weap)
		{
			fov = weap.CameraFOV;
			if (fov != oldFOV)
				TexMan.SetCameraToTexture(sc, "SCAMTEX1", fov);
		}
		
		oldPos = pos;
		oldFOV = fov;
	}
	
	override void RenderUnderlay(RenderEvent e)
	{
		if (!sc)
			return;
		
		// Calculate position to interpolate to
		let psp = players[consoleplayer].GetPSprite(PSP_WEAPON);
		if (psp)
			pos = (psp.x + sc.bob.x, (psp.y - WEAPONTOP) + sc.bob.y);
		else
			pos = oldPos;
		
		if (!sc.bDrawScope)
			return;
		
		Vector2 scale = statusBar.GetHUDScale();
		
		// Account for virtual resolutions
		int wOfs, hOfs, w, h;
		[wOfs, hOfs, w, h] = Screen.GetViewWindow();
		
		// Make sure scope stays proportional to resolution (based on 1920x1080)
		// Account for the status bar
		int height = Screen.GetHeight();
		double diff = height - (hOfs*2 + h);
		if (hOfs > 0)
			diff *= (h+diff) / 1080.;
		
		double multi = (h+diff) / 1080.;
		
		// Center screen then translate weapon offsets to the proper resolution
		Vector2 realPos = Lerp(oldPos, pos, e.fracTic);
		double x = wOfs + w/2. + realPos.x * scale.x * (w*1./Screen.GetWidth());
		double y = hOfs +  h/2. + realPos.y * scale.y * ((h+diff)*1./height);
		Vector2 size = TexMan.GetScaledSize(lens);
		
		DrawScope(lens, size.x/2 * multi, (x,y));
	}
	
	ui Scope FindScope(uint playernum)
	{
		if (playernum >= MAXPLAYERS)
			return null;
		
		ThinkerIterator it = ThinkerIterator.Create("Scope", Thinker.STAT_DEFAULT);
		Scope mo;
		while (mo = Scope(it.Next()))
		{
			if (mo && mo.master == players[playernum].mo)
				return mo;
		}
		
		return null;
	}
	
	// rad = radius of circle (using half width of texture is recommended)
	// verts describes how detailed the circle of the scope is
	// more verts = higher resolution circle but higher performance cost
	ui void DrawScope(TextureID id, double rad, Vector2 pos, uint verts = 32)
    {
        Shape2D circle = new("Shape2D");
		
		double angStep = 360 / verts;
		double ang;
		for (uint i = 0; i < verts; ++i)
		{
			double c = cos(ang);
			double s = sin(ang);
			
			circle.PushCoord(((c+1)/2, (s+1)/2));
			
			if (i+2 < verts)
				circle.PushTriangle(0, i+1, i+2);
			
			circle.PushVertex((c*rad + pos.x, s*rad + pos.y));
			
			ang += angStep;
		}
		
		Screen.DrawShape(id, false, circle);
    }
	
	ui Vector2 Lerp(in Vector2 a, in Vector2 b, double t)
	{
		return a*(1-t) + b*t;
	}
}

class Scope : Actor
{
	private Vector3 prevPos;
	private Vector2 prevAngles;
	private Vector2 prevOffset;
	
	Vector2 bob;
	bool bDrawScope;
	
	double forwardOffset;
	double sideOffset;
	double upOffset;
	
	property ForwardOffset : forwardOffset;
	property SideOffset : sideOffset;
	property UpOffset : upOffset;
	
	Default
	{
		Scope.ForwardOffset 4;
		Height 0;
		Radius 0;
		
		+INTERPOLATEANGLES
		+NOINTERACTION
		+NOBLOCKMAP
	}
	
	override void Tick()
	{
		if (!master || !master.player || master.health <= 0)
		{
			bDrawScope = false;
			return;
		}
		
		// Check if zoom pressed (acts as a toggle)
		if ((master.player.cmd.buttons & BT_ZOOM) && !(master.player.oldbuttons & BT_ZOOM))
			bDrawScope = !bDrawScope;
		
		if (!master.player.ReadyWeapon || master.player.ReadyWeapon.CameraFOV <= 0)
			bDrawScope = false;
		
		bob = (0,0);
		if (master.player.vel != (0,0))
			bob = master.player.mo.BobWeapon(1);
		
		Vector2 angles = (master.angle, master.pitch);
		Vector3 viewPos = (master.pos.xy, master.player.viewz);
		Vector2 offset = (0,0);
		let psp = master.player.GetPSprite(PSP_WEAPON);
		if (psp)
			offset = (psp.x, psp.y - WEAPONTOP);
		
		if (viewPos == prevPos && angles == prevAngles && offset == prevOffset)
		{
			roll = master.roll;
			return;
		}
		
		Vector2 forOfs = AngleToVector(master.angle);
		Vector3 forward = (forOfs*cos(master.pitch), -sin(master.pitch));
		
		Vector2 xyOfs;
		double zOfs;
		if (psp)
		{
			xyOfs = AngleToVector(master.angle-90, (psp.x + bob.x)/8 + sideOffset);
			zOfs = ((psp.y - WEAPONTOP) + bob.y) / 8;
		}
		else
			xyOfs = AngleToVector(master.angle-90, sideOffset);
		
		Vector3 newPos = master.pos + forward*(master.radius/2) +
						(forOfs*forwardOffset + xyOfs, upOffset + (master.player.viewz-master.pos.z) - zOfs);
						
		SetXYZ(newPos);
		angle = master.angle;
		pitch = master.pitch;
		roll = master.roll;
		
		prevPos = viewPos;
		prevAngles = angles;
		prevOffset = offset;
	}
}