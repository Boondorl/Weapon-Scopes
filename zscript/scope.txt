//version "2.4"

class ScopeHandler : EventHandler
{
	ui double oldFOV;
	ui Vector2 oldPos;
	ui Vector2 pos;
	ui Scope sc;
	ui TextureID lens;
	
	override void WorldLoaded(WorldEvent e)
	{
		// Reset scope drawing if reentering a level
		if (e.isReopen)
		{
			ThinkerIterator it = ThinkerIterator.Create("Scope", Thinker.STAT_DEFAULT);
			Scope mo;
			while (mo = Scope(it.Next()))
			{
				if (mo)
					mo.bDrawScope = false;
			}
			
			return;
		}
		
		// Spawn a scope actor for each player when entering a new level
		for (uint i = 0; i < MAXPLAYERS; ++i)
		{
			if (!playerInGame[i] || !players[i].mo)
				continue;
			
			let cam = Actor.Spawn("Scope");
			if (cam)
				cam.master = players[i].mo;
		}
	}
	
	override void UITick()
	{
		// Check valid player scope
		if (!sc)
			sc = FindScope(consoleplayer);
		
		// Check valid camera texture
		if (!lens.IsValid())
			lens = TexMan.CheckForTexture("SCAMTEX1", TexMan.Type_Any);
		
		// Update scope if weapon camera FOV changed
		double fov = oldFOV;
		let weap = players[consoleplayer].ReadyWeapon;
		if (weap)
		{
			fov = weap.CameraFOV;
			if (fov != oldFOV)
				TexMan.SetCameraToTexture(sc, "SCAMTEX1", fov);
		}
		
		oldPos = pos;
		oldFOV = fov;
	}
	
	override void RenderUnderlay(RenderEvent e)
	{
		if (!sc)
			return;
		
		// Calculate position to interpolate to
		let psp = players[consoleplayer].GetPSprite(PSP_WEAPON);
		if (psp)
			pos = (psp.x + sc.bob.x, (psp.y - WEAPONTOP) + sc.bob.y);
		else
			pos = oldPos;
		
		if (!sc.bDrawScope)
			return;
		
		// Account for virtual resolutions
		int wOfs, hOfs, w, h;
		[wOfs, hOfs, w, h] = Screen.GetViewWindow();
		
		// Make sure scope stays proportional to resolution (based on 1920x1080)
		double multi = h / 1080.;
		
		// Center screen then translate weapon offsets to the proper resolution
		Vector2 scale = statusBar.GetHUDScale();
		double x = wOfs + w/2 + (oldPos.x + (pos.x - oldPos.x)*e.fracTic) * scale.x * (w*1./Screen.GetWidth());
		double y = hOfs +  h/2 + (oldPos.y + (pos.y - oldPos.y)*e.fracTic) * scale.y * (h*1./Screen.GetHeight());
		Vector2 size = TexMan.GetScaledSize(lens);
		
		DrawScope(lens, size.x/2 * multi, (x,y));
	}
	
	ui Scope FindScope(uint playernum)
	{
		if (playernum >= MAXPLAYERS)
			return null;
		
		ThinkerIterator it = ThinkerIterator.Create("Scope", Thinker.STAT_DEFAULT);
		Scope mo;
		while (mo = Scope(it.Next()))
		{
			if (mo && mo.master == players[playernum].mo)
				return mo;
		}
		
		return null;
	}
	
	// rad = radius of circle (using half width of texture is recommended)
	// verts describes how detailed the circle of the scope is
	// more verts = higher resolution circle but higher performance cost
	ui void DrawScope(TextureID id, double rad, Vector2 pos, uint verts = 32)
    {
        Shape2D circle = new("Shape2D");
		
		double angStep = 360 / verts;
		double ang;
		for (uint i = 0; i < verts; ++i)
		{
			double c = cos(ang);
			double s = sin(ang);
			
			circle.PushCoord(((c+1)/2, (s+1)/2));
			
			if (i+2 < verts)
				circle.PushTriangle(0, i+1, i+2);
			
			circle.PushVertex((c*rad + pos.x, s*rad + pos.y));
			
			ang += angStep;
		}
		
		Screen.DrawShape(id, false, circle);
    }
}

class Scope : Actor
{
	Vector2 bob;
	bool bDrawScope;
	
	double forwardOffset;
	double sideOffset;
	double upOffset;
	
	property ForwardOffset : forwardOffset;
	property SideOffset : sideOffset;
	property UpOffset : upOffset;
	
	Default
	{
		Scope.ForwardOffset 4;
		Height 0;
		Radius 0;
		
		+NOINTERACTION
	}
	
	override void Tick()
	{
		if (!master || !master.player || master.health <= 0)
		{
			bDrawScope = false;
			return;
		}
		
		// Check if zoom pressed (acts as a toggle)
		if ((master.player.cmd.buttons & BT_ZOOM) && !(master.player.oldbuttons & BT_ZOOM))
			bDrawScope = !bDrawScope;
		
		if (!master.player.ReadyWeapon || master.player.ReadyWeapon.CameraFOV <= 0)
			bDrawScope = false;
		
		Vector2 forOfs = AngleToVector(master.angle);
		Vector3 forward = (forOfs*cos(master.pitch), -sin(master.pitch));
		
		bob = master.player.mo.BobWeapon(1);
		
		Vector2 xyOfs;
		double zOfs;
		let psp = master.player.GetPSprite(PSP_WEAPON);
		if (psp)
		{
			xyOfs = AngleToVector(master.angle-90, (psp.x + bob.x)/8 + sideOffset);
			zOfs = ((psp.y - WEAPONTOP) + bob.y) / 8;
		}
		else
			xyOfs = AngleToVector(master.angle-90, sideOffset);
		
		Vector3 newPos = master.pos + forward*(master.radius/2) +
						(forOfs*forwardOffset + xyOfs, upOffset + (master.player.viewz-master.pos.z) - zOfs);
						
		SetOrigin(newPos, true);
		A_SetAngle(master.angle, SPF_INTERPOLATE);
		A_SetPitch(master.pitch, SPF_INTERPOLATE);
		roll = master.roll;
	}
}