version "4.3"

class ScopeHandler : EventHandler
{
	ui double oldFOV;
	ui Vector2 oldPos;
	ui Vector2 pos;
	ui Scope sc;
	ui TextureID lens;
	
	override void WorldLoaded(WorldEvent e)
	{
		if (e.isReopen)
			return;
		
		for (uint i = 0; i < MAXPLAYERS; ++i)
		{
			if (!playerInGame[i] || !players[i].mo)
				continue;
			
			let cam = Actor.Spawn("Scope");
			if (cam)
				cam.master = players[i].mo;
		}
	}
	
	override void UITick()
	{
		if (!sc)
			sc = FindScope(consoleplayer);
		
		if (!lens.IsValid())
			lens = TexMan.CheckForTexture("SCAMTEX1", TexMan.Type_Any);
		
		double fov = oldFOV;
		let weap = players[consoleplayer].ReadyWeapon;
		if (weap)
		{
			fov = weap.CameraFOV;
			if (fov != oldFOV)
				TexMan.SetCameraToTexture(sc, "SCAMTEX1", fov);
		}
		
		oldPos = pos;
		oldFOV = fov;
	}
	
	override void RenderUnderlay(RenderEvent e)
	{
		if (!sc)
			return;
		
		pos = (sc.xOffset, sc.yOffset);
		if (!sc.bDrawScope)
			return;
		
		int h = Screen.GetHeight();
		double multi = h / 1080.;
		
		Vector2 scale = statusBar.GetHUDScale();
		double x = Screen.GetWidth() / 2 + (oldPos.x + (pos.x - oldPos.x)*e.fracTic)*scale.x;
		double y = h / 2 + (oldPos.y + (pos.y - oldPos.y)*e.fracTic)*scale.y;
		Vector2 size = TexMan.GetScaledSize(lens);
		
		DrawScope(lens, size.x/2 * multi, (x,y));
	}
	
	ui Scope FindScope(uint playernum)
	{
		if (playernum >= MAXPLAYERS)
			return null;
		
		ThinkerIterator it = ThinkerIterator.Create("Scope", Thinker.STAT_DEFAULT);
		Scope mo;
		while (mo = Scope(it.Next()))
		{
			if (mo && mo.master == players[playernum].mo)
				return mo;
		}
		
		return null;
	}
	
	ui void DrawScope(TextureID id, double rad, Vector2 pos, uint verts = 32)
    {
        Shape2D circle = new("Shape2D");
		
		double angStep = 360 / verts;
		double ang;
		for (uint i = 0; i < verts; ++i)
		{
			double c = cos(ang);
			double s = sin(ang);
			
			circle.PushCoord(((c+1)/2, (s+1)/2));
			
			if (i+2 < verts)
				circle.PushTriangle(0, i+1, i+2);
			
			circle.PushVertex((c*rad + pos.x, s*rad + pos.y));
			
			ang += angStep;
		}
		
		Screen.DrawShape(id, false, circle);
    }
}

class Scope : Actor
{
	double xOffset;
	double yOffset;
	bool bDrawScope;
	
	double forwardOffset;
	double sideOffset;
	double upOffset;
	
	property ForwardOffset : forwardOffset;
	property SideOffset : sideOffset;
	property UpOffset : upOffset;
	
	Default
	{
		Scope.ForwardOffset 4;
		
		Height 0;
		Radius 0;
		
		+NOINTERACTION
	}
	
	override void Tick()
	{
		if (!master || !master.player)
			return;
		
		if ((master.player.cmd.buttons & BT_ZOOM) && !(master.player.oldbuttons & BT_ZOOM))
			bDrawScope = !bDrawScope;
		
		if (!master.player.ReadyWeapon)
			bDrawScope = false;
		
		Vector2 forOfs = AngleToVector(master.angle);
		Vector3 forward = (forOfs*cos(master.pitch), -sin(master.pitch));
		
		let psp = master.player.GetPSprite(PSP_WEAPON);
		let bob = master.player.mo.BobWeapon(1);
		
		xOffset = psp.x + bob.x;
		yOffset = (psp.y - WEAPONTOP) + bob.y;
		
		Vector2 xyOfs = AngleToVector(master.angle-90, (xOffset/4 + sideOffset));
		double zOfs = yOffset / 4;
		
		Vector3 newPos = master.pos + forward*(master.radius/2) +
						(forOfs*forwardOffset + xyOfs, upOffset + master.player.viewHeight - master.floorclip - zOfs);
						
		SetOrigin(newPos, true);
		A_SetAngle(master.angle, SPF_INTERPOLATE);
		A_SetPitch(master.pitch, SPF_INTERPOLATE);
		roll = master.roll;
	}
}

class NewChaingun : Chaingun replaces Chaingun
{
	Default
	{
		Weapon.SlotNumber 4;
		CameraFOV 10;
	}
}